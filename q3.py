# -*- coding: utf-8 -*-
"""Q3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KRYB-dCuWKLptdXQVk-oMUBRCKgYvqH_
"""

import numpy as np
import matplotlib.pyplot as plt
from PIL import Image
from google.colab import files

# Upload the image to Colab
uploaded = files.upload()

# Function to perform upsampling by inserting zeros between pixels
def upsample_image(image):
    upsampled = np.zeros((image.shape[0] * 2, image.shape[1] * 2), dtype=image.dtype)
    upsampled[::2, ::2] = image
    return upsampled

# Function to create a 2D Gaussian kernel given the kernel size (k) and sigma (σ)
def create_gaussian_kernel(size, sigma):
    x = np.linspace(-(size // 2), size // 2, size)
    y = np.linspace(-(size // 2), size // 2, size)
    xx, yy = np.meshgrid(x, y)

    kernel = np.exp(-0.5 * (xx**2 + yy**2) / (sigma**2))
    kernel /= np.sum(kernel)

    return kernel

# Function to apply 2D convolution with zero padding
def apply_convolution(image, kernel):
    img_height, img_width = image.shape
    kernel_height, kernel_width = kernel.shape

    pad_height = kernel_height // 2
    pad_width = kernel_width // 2

    padded_image = np.pad(image, ((pad_height, pad_height), (pad_width, pad_width)), mode='constant')

    output_image = np.zeros_like(image)

    for i in range(img_height):
        for j in range(img_width):
            region = padded_image[i:i + kernel_height, j:j + kernel_width]
            output_image[i, j] = np.sum(region * kernel)

    return output_image

# Function to apply Gaussian smoothing
def gaussian_smoothing(image, kernel):
    height, width = image.shape
    k_size = kernel.shape[0]
    pad = k_size // 2
    padded_img = np.pad(image, pad_width=pad, mode='edge')
    smoothed_img = np.zeros_like(image)

    # Convolve the kernel over the image
    for i in range(height):
        for j in range(width):
            smoothed_img[i, j] = np.sum(padded_img[i:i+k_size, j:j+k_size] * kernel)

    return smoothed_img

# Function to perform median filtering
def median_filter(image, filter_size):
    img_height, img_width = image.shape
    pad_size = filter_size // 2
    padded_image = np.pad(image, pad_size, mode='constant')

    filtered_image = np.zeros_like(image)

    for i in range(img_height):
        for j in range(img_width):


            filtered_image[i, j] = np.median(region)

    return filtered_image

# Load the uploaded image
image_path = list(uploaded.keys())[0]
image = Image.open(image_path).convert('L')
image_array = np.array(image)

# Step 1: Perform upsampling
upsampled_image = upsample_image(image_array)

def gaussian_smoothing(image, kernel_size, sigma):
    # Implement Gaussian smoothing logic here
    pass

# Step 2: Apply Gaussian smoothing with k=11, σ=1
smoothed_image_gaussian = gaussian_smoothing(upsampled_image, kernel_size=11, sigma=1)

# Step 3: Apply median filtering
def median_filter(image, filter_size=11):
    # Assuming 'image' is a 2D numpy array
    padded_image = np.pad(image, pad_width=filter_size//2, mode='edge')
    filtered_image = np.zeros_like(image)

    # Iterate over the image pixels
    for i in range(image.shape[0]):
        for j in range(image.shape[1]):
            # Extract the region (filter_size x filter_size) around the pixel (i, j)
            region = padded_image[i:i + filter_size, j:j + filter_size]

            # Apply the median filter by calculating the median of the region
            filtered_image[i, j] = np.median(region)

    return filtered_image

smoothed_image_median = median_filter(upsampled_image, filter_size=11)

# Original upsampled image
# Plot the results
plt.figure(figsize=(15, 10))
plt.subplot(1, 3, 2)
plt.imshow(upsampled_image, cmap='gray')
plt.title('Upsampled Image')

# Median filtered image
plt.figure(figsize=(15, 10))
plt.subplot(1, 3, 3)
plt.imshow(smoothed_image_median, cmap='gray')
plt.title('Median Filter (k=11)')
plt.tight_layout()
plt.show()